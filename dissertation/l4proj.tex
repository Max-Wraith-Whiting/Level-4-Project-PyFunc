% REMEMBER: You must not plagiarise anything in your report. Be extremely careful.

\documentclass{l4proj}

    
%
% put any additional packages here
%

\begin{document}

%==============================================================================
%% METADATA
\title{Pythonic Syntax, Functional Core}
\author{Maxwell A. Wraith-Whiting}
\date{January 8th, 2024}

\maketitle

%==============================================================================
%% ABSTRACT
\begin{abstract}
    Every abstract follows a similar pattern. Motivate; set aims; describe work; explain results.
    \vskip 0.5em
    ``XYZ is bad. This project investigated ABC to determine if it was better. 
    ABC used XXX and YYY to implement ZZZ. This is particularly interesting as XXX and YYY have
    never been used together. It was found that  
    ABC was 20\% better than XYZ, though it caused rabies in half of subjects.''


    (Introduction) - The goal of the project is to produce a proof-of-concept functional programming language that utilises a Hindley-Milner type system.
     This is for the explicit purpose of utilising Python's ease of use whilst leveraging functional programming's correctness and type-safety.
    (Methods) - In this project I made the prototype language and ran it in contrast to Python 3.* over several test benchmarks.
    (Results) - The new language proved to be [GOOD / BAD]
    (Discussion) - The future relevance of this type of language is significant as the the computer science world turns its attentions to the functional paradigm.


    The allowance of state in modern high-level programming is a mistake.
    Many of the most popular programming languages of today are riddled with state, for example: Python.
    This project aims to explore and mitigate the issue of state whilst rendering runtime-errors an unlikely possiblity instead of an inevitability.
    The [functional language] was created purely in OCaml, implementing the full language pipeline.
    FPL performed in a [similar/disimilar] manner to Python in the selected test-suites, though as a prototype, it could not compare for more advanced features.

\end{abstract}

%==============================================================================

% EDUCATION REUSE CONSENT FORM
% If you consent to your project being shown to future students for educational purposes
% then insert your name and the date below to  sign the education use form that appears in the front of the document. 
% You must explicitly give consent if you wish to do so.
% If you sign, your project may be included in the Hall of Fame if it scores particularly highly.
%
% Please note that you are under no obligation to sign 
% this declaration, but doing so would help future students.
%
%\def\consentname {My Name} % your full name
%\def\consentdate {20 March 2018} % the date you agree
%
\educationalconsent


%==============================================================================
\tableofcontents

%==============================================================================
%% Notes on formatting
%==============================================================================
% The first page, abstract and table of contents are numbered using Roman numerals and are not
% included in the page count. 
%
% From now on pages are numbered
% using Arabic numerals. Therefore, immediately after the first call to \chapter we need the call
% \pagenumbering{arabic} and this should be called once only in the document. 
%
% Do not alter the bibliography style.
%
% The first Chapter should then be on page 1. You are allowed 40 pages for a 40 credit project and 30 pages for a 
% 20 credit report. This includes everything numbered in Arabic numerals (excluding front matter) up
% to but excluding the appendices and bibliography.
%
% You must not alter text size (it is currently 10pt) or alter margins or spacing.
%
%
%==================================================================================================================================
%
% IMPORTANT
% The chapter headings here are **suggestions**. You don't have to follow this model if
% it doesn't fit your project. Every project should have an introduction and conclusion,
% however. 
%
%==================================================================================================================================
\chapter{Introduction}



% reset page numbering. Don't remove this!
\pagenumbering{arabic} 

% STARTSTART
-------------------

In modern software development there is a search for languages that offer the expressiveness, readability, and robustness.
Python is one of the most popular first languages among new learners standing as a highly readable, simple, versatile introduction to programming.
However, despite its popularity Python suffers from its imperative nature and poses challenges for developers embracing the increasingly popular functional paradigm.
This paper introduces a novel functional programming language inspired by Python’s syntax but with additional catering to functional programming.
The language aims to bridge the gap between the accessibility of Python and the robustness of languages like Haskell and Ocaml.
The core contributions of this project lie in the development and implementation of the language’s features:

\begin{itemize}
    \item Friendly Python-like Syntax
    \item Hindley-Milner Type System
    \item Simple Functional Constructs
\end{itemize}



% ENDEND
-------------------

\textbf{Why should the reader care about what are you doing and what are you actually doing?}

The C-like syntax of imperative languages is by far the most read and used programming syntax.
It lends itself to simplicity and variably terse series of instructions.

Functional programming languages are however completely distinct from this syntax style.
They often follow predecessors languages, like Lisp, more closely than their ubiquitous descendant.

The functional paradigm is one not generally approached by novice programmers.
It is not a place that allows easy learning for those inexperienced with programming in general.

Python is often cited [] as being a particularly easy first programming language, due to its friendly syntax, simple style, and powerful constructs.
The idea behind this project is a simple one.
Can the inherent safety and power of the functional paradigm be made more accessible to programmers more familiar with Python-like syntax and do Python-like languages benefit from these features.

% WHY!
% The functional paradigm itself suffers for lack of novice programmers and its academic ouvre.
% Functional languages have much to offer beyond their "catch-phrase" features.
% There exists no truly C-like functional language that does not approach academic malaise.

% I have a dream: That the safety and power, nay the \emph{joy} of programming in a functional language can be made accessible even to those only just learning to think like a programmer.
% That the complexity of certain structures in the languages do not breed the sort of terror that things like the word \emph{monad} can evoke in a Java programmer.

% \section{Guidance}

\textbf{Motivate} first, then state the general problem clearly. 

% \section{Writing guidance}
% \subsection{Who is the reader?}

This is the key question for any writing. Your reader:

\begin{itemize}
    \item
    is a trained computer scientist: \emph{don't explain basics}.
    \item
    has limited time: \emph{keep on topic}.
    \item
    has no idea why anyone would want to do this: \emph{motivate clearly}
    \item
    might not know \emph{anything} about your project in particular:
    \emph{explain your project}.
    \item
    but might know precise details and check them: \emph{be precise and
    strive for accuracy.}
    \item
    doesn't know or care about you: \emph{personal discussions are
    irrelevant}.
\end{itemize}

Remember, you will be marked by your supervisor and one or more members
of staff. You might also have your project read by a prize-awarding
committee or possibly a future employer. Bear that in mind.

% \subsection{References and style guides}
There are many style guides on good English writing. You don't need to
read these, but they will improve how you write.

\begin{itemize}
    \item
    \emph{How to write a great research paper} \cite{Pey17} (\textbf{recommended}, even though you aren't writing a research paper)
    \item
    \emph{How to Write with Style} \cite{Von80}. Short and easy to read. Available online.
    \item
    \emph{Style: The Basics of Clarity and Grace} \cite{Wil09} A very popular modern English style guide.
    \item
    \emph{Politics and the English Language} \cite{Orw68}  A famous essay on effective, clear writing in English.
    \item
    \emph{The Elements of Style} \cite{StrWhi07} Outdated, and American, but a classic.
    \item
    \emph{The Sense of Style} \cite{Pin15} Excellent, though quite in-depth.
\end{itemize}

\subsubsection{Citation styles}

\begin{itemize}
\item If you are referring to a reference as a noun, then cite it as: ``\citet{Orw68} discusses the role of language in political thought.''
\item If you are referring implicitly to references, use: ``There are many good books on writing \citep{Orw68, Wil09, Pin15}.''
\end{itemize}

There is a complete guide on good citation practice by Peter Coxhead available here: \url{http://www.cs.bham.ac.uk/~pxc/refs/index.html}. 
If you are unsure about how to cite online sources, please see this guide: \url{https://student.unsw.edu.au/how-do-i-cite-electronic-sources}.

% \subsection{Plagiarism warning}

\begin{highlight_title}{WARNING}
    
    If you include material from other sources without full and correct attribution, you are commiting plagiarism. The penalties for plagiarism are severe.
    Quote any included text and cite it correctly. Cite all images, figures, etc. clearly in the caption of the figure.
\end{highlight_title}


%==================================================================================================================================
\chapter{Background}
What did other people do, and how is it relevant to what you want to do?

Fundamentally, this project does not propose any new-fangled concept or magical algorithm.
It does not speak to the beauty of the universe in its refined ideas.

It is a simple idea, simply executed: Take what we have that works and combine them into one.

Python is approachable, easy to use, and fast (\emph{to write}).

The functional paradigm is powerful, terse, and very (\emph{very}) opaque.

Can it be made less opaque, less academic by shoe-horning in the syntax and ideas that belie Python?

Who is to say.

\section{Strengths of Pythonic Syntax}

Why is Python so popular? 
The language has many 'flaws' that other languages do not.
Machine Learning and Data Science are fields that from an purely intuitive perspective would value speed over everything, and yet Python is the go to language in a large majority of the technology of the fields.
Why is it such an attractive language for so many varied fields, from bioinformatics to finance, if it is so slow?

Speed of execution is not the only bottleneck in producing systems.
The speed of writing code, the speed of making changes, the speed of just attempting to get a working system is far more important than pure CPU execution time.
Python performs extremely well in these areas.
A user's time is more valuable than CPU time.
It's really easy to get started with.
Python is simple enough for anyone to get started in, but still powerful enough to hanlde large complex projects.

Python is considered slow, but often it is neglected to mention "in what context? Compared to what?"

It has reached the point of a stereotype that Python is slow.
Oftentimes, the ability to construct a program fast, to iterate quickly, is far more valuable than the CPU time it incurs.

The readablilty also play a significant part in the value of the language.
It is often stated that code will be read far more than it will be written.
The statement itself makes it intuitive that code should be inherently aimed at readability.

Python is a descendant of the C-family of syntaxes, with a few unique twists of its own, such as white-space indentation.
This ancestry gives programmers unfamiliar with the language a grounding, or more accurately an expectation, of how the code will behave based on its syntax.
Obviously, the exact semantics differ, but certain universals remain.

It is to Python's benefit that there is an effective understanding of the syntax of the language.
It is also likely why Python is so successful as a beginner language, as it informs new programmers of one of the most prevalent syntax's the collection of all of programming langauges.

So to short: Python's strengths lie in its syntax and semantics, not necessarily its implementation.
The value that this project aims to extract from it is not in its underlying structure but its front-facing interface.

\section{Benefits of the Functional Paradigm}

Functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions.
It avoids mutable state, often by enforcing data immutability.

Some of the key concepts include:

\begin{itemize}
    \item \textbf{Pure Functions:} Functions that, given the same input, always return the same output.
    This requires the restriction of access to mutable state inside functions that could interfere in the functions execution.
    (I.e., Functions do not depend on or modify variables outside of their scope.)
    \item \textbf{Immutable Data:} Data cannot be changed in-situ after creation.
    Instead of modification of data, functional programming encourages the creation of new variables with the desired changes.
    \item \textbf{Higher Order Functions:} Functions that can take functions as arguments or return them as results.
    A simple example is \emph{Map} which maps a function onto a give structure.
    \item \textbf{Referential Transparency:} The property that an expression can be replaced with its value without changing the program's behaviour. 
\end{itemize}

All of these concepts can be considered spectrums rather than hard rules, as many popular functional languages bend these concepts for usabilities sake.\footnote{Ocaml for instance is not a \emph{purely} functional programming language. It technically is a functional, imperative, and object-oritened programming language.}
Though these languages do make behaviour outside of the norm specified by these rules explicit and force the programmer to be deliberate with their forays outside of the paradigm.

Functional programming offers several advantages and addresses certain challenges inherent in other paradigms, such as imperative and object-oritened programming. 

\begin{itemize}
    \item \textbf{Clarity and Maintainability:} Functional programming emphasises (and sometimes enforces) pure functions and immutable data.
    By avoiding side-effects and mutable state, functional programs tend to be easier to reason about and maintain.
    \item \textbf{Conciseness and Expressiveness:} Functional programming languages often provide high-level abstractions and expressive syntax for common programming patterns, such as map, filter, and reduce operations.
    This can lead to shorter, more concise code that is easier to write and understand.
    \item \textbf{Robustness and Predictability:} Pure functions and immutable data make functional programs more robust and predictable.
    Since pure functions have no side effects, they can be unit-tested and debugged easily.
    Additionally, immutable data structures can help prevent common bugs related to unintended modifications of data.
    \item \textbf{Formal Verification:} Functional programming languages and techniques are often amenable to formal verification techniques, which can provide guarantees about the correctness of a program.
    This is a valuable trait in safety-critical and high-assurance applications.
\end{itemize}

These numerous powerful and useful features work across many contexts, but functional programming languages are not as commonly used as other languages like Python, Java, or JavaScript. 

\section{Type-Systems and Hindley-Milner}

% \section{Guidance}
% \begin{itemize}    
%     \item
%       Don't give a laundry list of references.
%     \item
%       Tie everything you say to your problem.
%     \item
%       Present an argument.
%     \item Think critically; weigh up the contribution of the background and put it in context.    
%     \item
%       \textbf{Don't write a tutorial}; provide background and cite
%       references for further information.
% \end{itemize}

%==================================================================================================================================
\chapter{Analysis/Requirements}
What is the problem that you want to solve, and how did you arrive at it?

[NOTE]: What is the problem
The dominant programming paradigm is imperative, no matter the uptick of interest in functional programming.
The current state of functional programming does not lend itself to easy entry for new programmers who will be the future of the paradigm.
The functional paradigm has many pitfalls for new developers:
\begin{itemize}
    \item Abstract concepts
    \item Mathematical foundations
    \item Lack of familiarity
    \item Limited resourses and support
    \item Complex error messages
    \item Perceived lack of practical applications
    \item steep learning curve
\end{itemize}

\section{Aims and Justification}
\section{Minimal Viable System}
\subsection{Frontend Syntax}
\subsection{Type-System}
The Hindley-Milner Type System offers several advantages in programming:

\begin{itemize}
    \item \textbf{Type Inference:} Hindley-Milner allows for type inference, which means that you don't have to explicitly annotate the types of every variable or function in your code.
    The type checker can often automatically infer the most general types, reducing the burden on the programmer and making the code more concise.
    \item \textbf{Type Safety:} Programs written in languages with Hindley-Milner type systems tend to have fewer type-related bugs because the compiler or interpreter can catch many type errors at compile time.
    This leads to more robust and reliable code.
    \item \textbf{Polymorphism:} Hindley-Milner supports parametric polymorphism, also known as generics in some languages.
    This allows you to write functions and data structures that can operate on a wide range of types without sacrificing type safety.
    This idea fundamentally aligns with the ideas behind a human-readable syntax, minimising 'boiler-plate' code whilst remaining expressive.
    \item \textbf{Expressiveness:} Despite being statically typed, Hindley-Milner type systems are quite expressive and flexible.
    They can handle complex type constraints and provide powerful abstractions for structuring programs.
    \item \textbf{Efficiency:} The type inference algorithm used in Hindley-Milner systems is efficent, making compilation or interpretation fast compared to more complex type systems.
\end{itemize}

As for alternatives:

\begin{itemize}
    \item \textbf{Dynamic Typing:} In languages with dynamic typing, such as Python itself, there is no static typechecking at compile time.
    Instead, types are checked at runtime, which can lead to type-related errors occuring during program execution rather than compile time. 
    While dynamic typing offers flexibility and rapid development, it can also make code harder to understand and maintain, and it may result in runtime type errors that could have been caught at compile time.
    This would be an underutilisation of the functional paradigm and would leave the language with issues that Python already suffers from, like upredictable type errors at runtime.
    \item \textbf{Dependent Typing:} Dependent type systems, found in languages like Idris and Agda, allow types to depend on values.
    This provides very strong guarantees about program correctness but can be complex to work with and may require explicit type annotations from the programmer.
    Adding type annotations dominates the syntax of the language, which defeats the point of aiming for a 'Pythonic' syntax.
    \item \textbf{Gradual Typing:} Graudal typing combines elements from static and dynamic typing, allowing programmers to choose when to use type annotations and when to rely on dynamic typing.
    This can be useful when transitioning existing codebases to a statically typed language or when working in areas where static typing is impractical or overly restricitive.
\end{itemize}

In cases where no type system is used at all, programmers have complete freedom but lose the benefits of type checking, such as early error detection and improved code documentation.
[NO]It is just insanity to be frank.
This approach can work well for small projects with dedicated teams but can become problematic as codebases grow larger and more complex.

\subsection{Language Features}

\section{Proposed Minimal Requirements}
% \section{Guidance}
Make it clear how you derived the constrained form of your problem via a clear and logical process. 

%==================================================================================================================================
\chapter{Design}
How is this problem to be approached, without reference to specific implementation details? 
\section{Frontend Syntax Design}
\subsection{IR Specification}
\section{Language Pipeline}
\subsection{To IR or not to IR}
\subsection{IR Conversion}
\section{Typechecking and Hindley Milner}
\subsection{Unification Algorithm}
\subsection{Typechecking Rules}
\section{Evaluation}
% \section{Guidance}
% Design should cover the abstract design in such a way that someone else might be able to do what you did, but with a different language or library or tool.

%==================================================================================================================================
\chapter{Implementation}
What did you do to implement this idea, and what technical achievements did you make?

\section{Parsing and Abstract Syntax Tree}
\section{Intermediate Representation}
\section{Hindley-Milner Typechecker}
\subsection{Type-Environments and Why We Need Them}
\subsection{Unification}
\subsection{Generalisation and Other Sins}
\subsection{Implementing the Typerchecker}
\subsection{The Not So Simple Typechecking}

% \section{Guidance}
% You can't talk about everything. Cover the high level first, then cover important, relevant or impressive details.



% \section{General points}

These points apply to the whole dissertation, not just this chapter.



% \subsection{Figures}
\emph{Always} refer to figures included, like Figure \ref{fig:relu}, in the body of the text. Include full, explanatory captions and make sure the figures look good on the page.
You may include multiple figures in one float, as in Figure \ref{fig:synthetic}, using \texttt{subcaption}, which is enabled in the template.



% Figures are important. Use them well.
\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{images/relu.pdf}    

    \caption{In figure captions, explain what the reader is looking at: ``A schematic of the rectifying linear unit, where $a$ is the output amplitude,
    $d$ is a configurable dead-zone, and $Z_j$ is the input signal'', as well as why the reader is looking at this: 
    ``It is notable that there is no activation \emph{at all} below 0, which explains our initial results.'' 
    \textbf{Use vector image formats (.pdf) where possible}. Size figures appropriately, and do not make them over-large or too small to read.
    }

    % use the notation fig:name to cross reference a figure
    \label{fig:relu} 
\end{figure}


\begin{figure}
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{images/synthetic.png}
        \caption{Synthetic image, black on white.}
        \label{fig:syn1}
    \end{subfigure}
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
      %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{images/synthetic_2.png}
        \caption{Synthetic image, white on black.}
        \label{fig:syn2}
    \end{subfigure}
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
    %(or a blank line to force the subfigure onto a new line)    
    \caption{Synthetic test images for edge detection algorithms. \subref{fig:syn1} shows various gray levels that require an adaptive algorithm. \subref{fig:syn2}
    shows more challenging edge detection tests that have crossing lines. Fusing these into full segments typically requires algorithms like the Hough transform.
    This is an example of using subfigures, with \texttt{subref}s in the caption.
    }\label{fig:synthetic}
\end{figure}

\clearpage

% \subsection{Equations}

Equations should be typeset correctly and precisely. Make sure you get parenthesis sizing correct, and punctuate equations correctly 
(the comma is important and goes \textit{inside} the equation block). Explain any symbols used clearly if not defined earlier. 

For example, we might define:
\begin{equation}
    \hat{f}(\xi) = \frac{1}{2}\left[ \int_{-\infty}^{\infty} f(x) e^{2\pi i x \xi} \right],
\end{equation}    
where $\hat{f}(\xi)$ is the Fourier transform of the time domain signal $f(x)$.

% \subsection{Algorithms}
Algorithms can be set using \texttt{algorithm2e}, as in Algorithm \ref{alg:metropolis}.

% NOTE: line ends are denoted by \; in algorithm2e
\begin{algorithm}
    \DontPrintSemicolon
    \KwData{$f_X(x)$, a probability density function returing the density at $x$.\; $\sigma$ a standard deviation specifying the spread of the proposal distribution.\;
    $x_0$, an initial starting condition.}
    \KwResult{$s=[x_1, x_2, \dots, x_n]$, $n$ samples approximately drawn from a distribution with PDF $f_X(x)$.}
    \Begin{
        $s \longleftarrow []$\;
        $p \longleftarrow f_X(x)$\;
        $i \longleftarrow 0$\;
        \While{$i < n$}
        {
            $x^\prime \longleftarrow \mathcal{N}(x, \sigma^2)$\;
            $p^\prime \longleftarrow f_X(x^\prime)$\;
            $a \longleftarrow \frac{p^\prime}{p}$\;
            $r \longleftarrow U(0,1)$\;
            \If{$r<a$}
            {
                $x \longleftarrow x^\prime$\;
                $p \longleftarrow f_X(x)$\;
                $i \longleftarrow i+1$\;
                append $x$ to $s$\;
            }
        }
    }
    
\caption{The Metropolis-Hastings MCMC algorithm for drawing samples from arbitrary probability distributions, 
specialised for normal proposal distributions $q(x^\prime|x) = \mathcal{N}(x, \sigma^2)$. The symmetry of the normal distribution means the acceptance rule takes the simplified form.}\label{alg:metropolis}
\end{algorithm}

% \subsection{Tables}

If you need to include tables, like Table \ref{tab:operators}, use a tool like https://www.tablesgenerator.com/ to generate the table as it is
extremely tedious otherwise. 

\begin{table}[]
    \caption{The standard table of operators in Python, along with their functional equivalents from the \texttt{operator} package. Note that table
    captions go above the table, not below. Do not add additional rules/lines to tables. }\label{tab:operators}
    %\tt 
    \rowcolors{2}{}{gray!3}
    \begin{tabular}{@{}lll@{}}
    %\toprule
    \textbf{Operation}    & \textbf{Syntax}                & \textbf{Function}                            \\ %\midrule % optional rule for header
    Addition              & \texttt{a + b}                          & \texttt{add(a, b)}                                    \\
    Concatenation         & \texttt{seq1 + seq2}                    & \texttt{concat(seq1, seq2)}                           \\
    Containment Test      & \texttt{obj in seq}                     & \texttt{contains(seq, obj)}                           \\
    Division              & \texttt{a / b}                          & \texttt{div(a, b) }  \\
    Division              & \texttt{a / b}                          & \texttt{truediv(a, b) } \\
    Division              & \texttt{a // b}                         & \texttt{floordiv(a, b)}                               \\
    Bitwise And           & \texttt{a \& b}                         & \texttt{and\_(a, b)}                                  \\
    Bitwise Exclusive Or  & \texttt{a \textasciicircum b}           & \texttt{xor(a, b)}                                    \\
    Bitwise Inversion     & \texttt{$\sim$a}                        & \texttt{invert(a)}                                    \\
    Bitwise Or            & \texttt{a | b}                          & \texttt{or\_(a, b)}                                   \\
    Exponentiation        & \texttt{a ** b}                         & \texttt{pow(a, b)}                                    \\
    Identity              & \texttt{a is b}                         & \texttt{is\_(a, b)}                                   \\
    Identity              & \texttt{a is not b}                     & \texttt{is\_not(a, b)}                                \\
    Indexed Assignment    & \texttt{obj{[}k{]} = v}                 & \texttt{setitem(obj, k, v)}                           \\
    Indexed Deletion      & \texttt{del obj{[}k{]}}                 & \texttt{delitem(obj, k)}                              \\
    Indexing              & \texttt{obj{[}k{]}}                     & \texttt{getitem(obj, k)}                              \\
    Left Shift            & \texttt{a \textless{}\textless b}       & \texttt{lshift(a, b)}                                 \\
    Modulo                & \texttt{a \% b}                         & \texttt{mod(a, b)}                                    \\
    Multiplication        & \texttt{a * b}                          & \texttt{mul(a, b)}                                    \\
    Negation (Arithmetic) & \texttt{- a}                            & \texttt{neg(a)}                                       \\
    Negation (Logical)    & \texttt{not a}                          & \texttt{not\_(a)}                                     \\
    Positive              & \texttt{+ a}                            & \texttt{pos(a)}                                       \\
    Right Shift           & \texttt{a \textgreater{}\textgreater b} & \texttt{rshift(a, b)}                                 \\
    Sequence Repetition   & \texttt{seq * i}                        & \texttt{repeat(seq, i)}                               \\
    Slice Assignment      & \texttt{seq{[}i:j{]} = values}          & \texttt{setitem(seq, slice(i, j), values)}            \\
    Slice Deletion        & \texttt{del seq{[}i:j{]}}               & \texttt{delitem(seq, slice(i, j))}                    \\
    Slicing               & \texttt{seq{[}i:j{]}}                   & \texttt{getitem(seq, slice(i, j))}                    \\
    String Formatting     & \texttt{s \% obj}                       & \texttt{mod(s, obj)}                                  \\
    Subtraction           & \texttt{a - b}                          & \texttt{sub(a, b)}                                    \\
    Truth Test            & \texttt{obj}                            & \texttt{truth(obj)}                                   \\
    Ordering              & \texttt{a \textless b}                  & \texttt{lt(a, b)}                                     \\
    Ordering              & \texttt{a \textless{}= b}               & \texttt{le(a, b)}                                     \\
    % \bottomrule
    \end{tabular}
    \end{table}
% \subsection{Code}

Avoid putting large blocks of code in the report (more than a page in one block, for example). Use syntax highlighting if possible, as in Listing \ref{lst:callahan}.

\begin{lstlisting}[language=python, float, caption={The algorithm for packing the $3\times 3$ outer-totalistic binary CA successor rule into a 
    $16\times 16\times 16\times 16$ 4 bit lookup table, running an equivalent, notionally 16-state $2\times 2$ CA.}, label=lst:callahan]
    def create_callahan_table(rule="b3s23"):
        """Generate the lookup table for the cells."""        
        s_table = np.zeros((16, 16, 16, 16), dtype=np.uint8)
        birth, survive = parse_rule(rule)

        # generate all 16 bit strings
        for iv in range(65536):
            bv = [(iv >> z) & 1 for z in range(16)]
            a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p = bv

            # compute next state of the inner 2x2
            nw = apply_rule(f, a, b, c, e, g, i, j, k)
            ne = apply_rule(g, b, c, d, f, h, j, k, l)
            sw = apply_rule(j, e, f, g, i, k, m, n, o)
            se = apply_rule(k, f, g, h, j, l, n, o, p)

            # compute the index of this 4x4
            nw_code = a | (b << 1) | (e << 2) | (f << 3)
            ne_code = c | (d << 1) | (g << 2) | (h << 3)
            sw_code = i | (j << 1) | (m << 2) | (n << 3)
            se_code = k | (l << 1) | (o << 2) | (p << 3)

            # compute the state for the 2x2
            next_code = nw | (ne << 1) | (sw << 2) | (se << 3)

            # get the 4x4 index, and write into the table
            s_table[nw_code, ne_code, sw_code, se_code] = next_code

        return s_table

\end{lstlisting}

%==================================================================================================================================
\chapter{Evaluation} 
How good is your solution? How well did you solve the general problem, and what evidence do you have to support that?

\section{Direct Comparison Code Comparison}

% \section{Guidance}
% \begin{itemize}
%     \item
%         Ask specific questions that address the general problem.
%     \item
%         Answer them with precise evidence (graphs, numbers, statistical
%         analysis, qualitative analysis).
%     \item
%         Be fair and be scientific.
%     \item
%         The key thing is to show that you know how to evaluate your work, not
%         that your work is the most amazing product ever.
% \end{itemize}
\section{Testing Agianst The CPython Test-Suite}

% \section{Evidence}
% Make sure you present your evidence well. Use appropriate visualisations, reporting techniques and statistical analysis, as appropriate.

% If you visualise, follow the basic rules, as illustrated in Figure \ref{fig:boxplot}:
% \begin{itemize}
% \item Label everything correctly (axis, title, units).
% \item Caption thoroughly.
% \item Reference in text.
% \item \textbf{Include appropriate display of uncertainty (e.g. error bars, Box plot)}
% \item Minimize clutter.
% \end{itemize}

% See the file \texttt{guide\_to\_visualising.pdf} for further information and guidance.

% \begin{figure}
%     \centering
%     \includegraphics[width=1.0\linewidth]{images/boxplot_finger_distance.pdf}    

%     \caption{Average number of fingers detected by the touch sensor at different heights above the surface, averaged over all gestures. Dashed lines indicate
%     the true number of fingers present. The Box plots include bootstrapped uncertainty notches for the median. It is clear that the device is biased toward 
%     undercounting fingers, particularly at higher $z$ distances.
%     }

%     % use the notation fig:name to cross reference a figure
%     \label{fig:boxplot} 
% \end{figure}


% %==================================================================================================================================


\chapter{Conclusions}    
Summarise the whole project for a lazy reader who didn't read the rest (e.g. a prize-awarding committee).
% \section{Guidance}
\begin{itemize}
    \item
        Summarise briefly and fairly.
    \item
        You should be addressing the general problem you introduced in the
        Introduction.        
    \item
        Include summary of concrete results (``the new compiler ran 2x
        faster'')
    \item
        Indicate what future work could be done, but remember: \textbf{you
        won't get credit for things you haven't done}.
\end{itemize}

%==================================================================================================================================
%
% 
%==================================================================================================================================
%  APPENDICES  

\begin{appendices}

\chapter{Appendices}

\section{User Guide}
\subsection{Install}
\subsection{Shell Commands}
\subsection{Example Programs}
\section{Full Parser Grammar}

Typical inclusions in the appendices are:

\begin{itemize}
\item
  Copies of ethics approvals (required if obtained)
\item
  Copies of questionnaires etc. used to gather data from subjects.
\item
  Extensive tables or figures that are too bulky to fit in the main body of
  the report, particularly ones that are repetitive and summarised in the body.

\item Outline of the source code (e.g. directory structure), or other architecture documentation like class diagrams.

\item User manuals, and any guides to starting/running the software.

\end{itemize}

\textbf{Don't include your source code in the appendices}. It will be
submitted separately.

\end{appendices}

%==================================================================================================================================
%   BIBLIOGRAPHY   

% The bibliography style is abbrvnat
% The bibliography always appears last, after the appendices.

\bibliographystyle{abbrvnat}

\bibliography{l4proj}



\end{document}
